/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Rishabhdeep Singh
 */

// doot diddly donger cuckerino Hahahahahah
#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

#define PB              push_back
#define EB              emplace_back
#define F               first
#define S               second
#define all(a)          (a).begin(),(a).end()
#define sz(x)           (int)(x).size()
#define REP(x, n)       for(ll x = 0; x < n; ++x)
#define Unique(x)       sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));
#define IOS             ios::sync_with_stdio(false);cin.tie(NULL); cout << fixed << setprecision(12)
#define IN_REP          int tt; cin >> tt; while(tt--)
#define FORE(x, a)      for_each(all(a), [](auto& x)
#define sim             template<class T
#define ris             return * this
#define dor             > debug & operator <<
#define eni(x)          sim > typename enable_if<sizeof dud<T>(0) x 1, debug&>::type operator<<(T i)
sim> struct rge { T b, e; };
sim> rge<T> range(T i, T j) { return rge<T>{i, j}; }
sim> auto dud(T *x) -> decltype(cout << *x, 0);
sim> char dud(...);
struct debug {
#ifdef LOCAL
  ~debug() { cout << endl; }
  eni(!=) {
      cout << boolalpha << i;
      ris;
  }
  eni(==) { ris << range(all(i)); }
  sim, class U dor(pair<U, T> d) { ris << "(" << d.first << ", " << d.second << ")"; }
  sim dor(rge<T> d) {
      *this << "[";
      for (auto it = d.b; it != d.e; ++it) *this << ", " + 2 * (it == d.b) << *it;
      ris << "]";
  }
#else
  sim dor(const T&) { ris; }
#endif
};
#define pr(...) " [" << #__VA_ARGS__ ": " << (__VA_ARGS__) << "] "

using ll = long long;
using ull = unsigned long long;
using ld = long double;
using vi = vector<int>;
using vb = vector<bool>;
using vvi = vector<vi>;
using vll = vector<ll>;
using vvll = vector<vll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using vpii = vector<pii>;
using vpll = vector<pll>;
using ordered_set = tree<int, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update>;

const ld EPS = (ld) 1e-9;
const ll MOD = (ll) 1e9 + 7;
const ld PI = acos(-1);
const int N = (int) 5e6 + 5;

sim> T gcd(T x, T y) { return (y == 0) ? x : gcd(y, x % y); }
sim> void mini(T& x, T y) { x = min(x, y); }
sim> void maxi(T& x, T y) { x = max(x, y); }
sim, class U> string to_string(pair<T, U> p) { return to_string(p.F) + " " + to_string(p.S); }
mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());

#include <utility>

//
// Created by White Knife on 25/09/19.
//
//
//#ifndef CPP_LIBRARY_DSU_HPP_
//#define CPP_LIBRARY_DSU_HPP_

class DSU {
    int n;
  public:
    vector<int> par;
    vector<long long> rank;

    DSU(int _n) : n(_n) {
        par.resize(n);
        rank.resize(n);
        for (int i = 0; i < n; ++i) {
            par[i] = i;
            rank[i] = 1;
        }
    }
    DSU(vector<long long>& _rank) {
        rank = _rank;
        n = rank.size();
        par.resize(n);
        iota(par.begin(), par.end(), 0);
    }
    int Root(int x) {
        return x == par[x] ? x : par[x] = Root(par[x]);
    }
    bool Unite(int x, int y) {
        x = Root(x);
        y = Root(y);
        if (x == y) return true;
        if (rank[x] > rank[y]) {
            par[y] = x;
            rank[x] += rank[y];
        } else if (rank[y] > rank[x]) {
            par[x] = y;
            rank[y] += rank[x];
        } else {
            par[x] = y;
            rank[y]++;
        }
        return false;
    }
    int Count() {
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            if (Root(i) == i) cnt++;
        }
        return cnt;
    }
};
//#endif //CPP_LIBRARY_DSU_HPP_


class BytelandianBlingorsNetwork {
  public:
    map<pair<int, int>, bool> vis;
    void solve(std::istream& cin, std::ostream& cout) {
        IN_REP {
            int n;
            cin >> n;
            vis.clear();
            vector<pair<pii, int>> graph;
            DSU dsu(n);
            for (int i = 0; i < n; ++i) {
                string ttt;
                cin >> ttt;
                int m;
                cin >> m;
                for (int j = 0; j < m; ++j) {
                    int v, cst;
                    cin >> v >> cst;
                    if (i < v)
                        graph.push_back({{i, v - 1}, cst});
                }
            }
            sort(all(graph), [&](pair<pii, int> x, pair<pii, int> y) {
                return x.S < y.S;
            });
            ll ans = 0;
            for (auto edge: graph) {
                int x = edge.F.F;
                int y = edge.F.S;
                bool ok = dsu.Unite(x, y);
                if (!ok) {
                    ans += edge.S;
                }
            }
            cout << ans << endl;
        };
    }
};

int main() {
    IOS;
	BytelandianBlingorsNetwork solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
